# 최소신장트리(MST, Minimum Spanning Tree)
그래프에서 고립된 정점 없이 모든 정점을 최소비용으로 연결하는 것을 스패닝 트리라고 한다.         
가중치 그래프의 스패닝 트리 중 가중치의 합이 가장 작은 트리를 찾는 문제를 최소 스패닝 트리 문제라고 한다.     
스패닝 트리의 문제를 해결하는 방법으로는 `KRUSCAL`알고리즘과 `PRIM`알고리즘이 있다.   
그렇다면 스패닝 트리의 의미는 무엇이며 MST 문제를 해결하기 위한 알고리즘은 어떻게 구현하는지 알아보도록 하자.  


## 1. 신장 트리(Spanning Tree)란?
- **신장트리(Spanning Tree)**     
   → `n`개의 정점으로 이루어진 무향 그래프에서 `n`개의 정점과 `n-1`간선으로 이루어진 부분 그래프      
   → 이 때, 스패닝 트리에 포함된 간선들은 정점들을 트리 형태로 전부 연결해야 한다.     
   > 트리 형태의 의미란 간선들이 사이클을 이루지 않는다는 의미이며, 정점들이 부모-자식 관계로 연결되어야 한다는 의미는 아닙니다.

<div align="center">
  <img src="https://user-images.githubusercontent.com/84266499/155564700-c55b8825-3417-438d-9dc8-03a96877410b.png" width="80%" height="80%"/>
</div>
<br>

  > 위의 예시에서 왼쪽의 경우 사이클이 있고, 모든 정점들이 하나로 연결되지 않았기 때문에 올바르지 않은 스패닝 트리이다.        
    
<br>    
<br>
    
- **최소 신장트리(Minimum Spanning Tree)**      
그렇다면 당연히도 가중치 그래프의 스패닝 트리들 중에서 간선들의 가중치 합이 최소인 경우를 최소 스패닝 트리라고 한다.    

## 2. 스패닝 트리 알고리즘      
### 2.0 브루트포스로 최소 스패닝 트리를 구할 수 있을까?   
그래프에 `n`개의 정점이 있을 때 그래프의 모든 정점을 연결하기 위해서는 `n-1`개의 간선이 필요할 것이다.     
스패닝 트리를 구하기 위해서 브루트포스 알고리즘을 사용해보자.     
완전 그래프로 예시를 들어보면 완전 그래프에서 간선의 개수는 `n*(n-1)/2`개이고, 이 간선들 중에 `n-1`개의 간선을 뽑는다고 하면 경우의 수는 아래와 같이 나오게 된다.    
![image](https://user-images.githubusercontent.com/84266499/155570034-ef343b6b-8581-42fc-a543-01e6c1b96fa0.png)        
이 경우에 정점이 10개밖에 존재하지 않더라도 `886163135(약 9억)`의 가지의 경우의 수가 존재한다. 그러니 스패닝 트리를 완전탐색으로 구하려는 시도는 잠시 접어두고, 앞으로 소개할 두 탐욕적인 알고리즘을 사용해주도록 하자.    


### 2.1 KRUSCAL 알고리즘     
