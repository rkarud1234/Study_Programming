# 스레드 이전의 비동기처리 방식

## 1. 프로세스
### 1.1 프로세스란?
사용자가 OS에게 프로그램을 실행시켜달라고 요청하면, OS는 사용자가 요청한 프로그램을 보조기억장치에서 찾아서 메모리로 가지고온다.    
여기서 보조기억장치의 프로그램을 메모리로 끌어올리는 작업을 LOAD라고 하며, 실제로 메모리에 올라가서 실행중인 살아있는 프로그램을 프로세스라고 한다.

<div align="center">
  <img src="https://user-images.githubusercontent.com/84266499/154540567-fe8eec7e-95ac-4e85-acaf-d6bf5799ac8a.png" width="760" height="500"/>
</div>

> 실제로 작업관리자를 켜보면 현재 실행중인 프로세스들의 목록을 볼 수 있다.

<div align="center">
  <img src="https://user-images.githubusercontent.com/84266499/154543688-6a445bfd-291f-49d2-a937-80e3c1469761.png" width="600" height="350"/>
</div>

<br>

### 1.2 프로세스의 동작방식
스레드로 비동기를 처리하기 이전에도, 다수의 프로그램이 작동중일 때 아마 우리가 보기에는 많은 프로세스들이 동시에 작동하는 것처럼 보일 것이다. 예를 들어 웹서핑을 하면서 음악을 듣는다고 하면, 우리는 웹 브라우저와 음악 플레이어가 동시에 실행되고 있는 것처럼 보일 것이다.     
하지만 실제로도 과연 동시에 실행되고 있을까?   

<div align="center">
  <img src="https://user-images.githubusercontent.com/84266499/154544683-84223404-81e5-487f-a8aa-6740e01f2e54.png" width="380" height="250"/>
</div>


프로세스의 실행은 CPU에서 담당하는데, 만약 CPU가 하나밖에 없다면 여러 개의 프로세스를 동시에 실행할 수 없을 것이다.   
하지만 동시에 실행되는 것처럼 보일 수는 있다.    
바로 OS의 **시분할(Time Share)** 이다.

<div align="center">
  <img src="https://user-images.githubusercontent.com/84266499/154707905-afef7cbb-6d0e-4fac-b24f-c7e5d94fcaac.png" width="550" height="600"/>
</div>

위 그림과 같이 하나의 CPU가 여러 개의 프로세스들을 우리는 눈치채지 못할 정도로 빠르게 순회하며 조금씩 실행한다. 하나의 CPU를 시분할하여 소모하는 것이다.     
이것을 **멀티태스크**, 혹은 **멀티프로세스**라고 한다.

<br>

### 1.3 멀티태스킹 동작 방식
멀티태스킹을 하기 위해서는 프로세스들을 순회하면서 프로세스를 잠깐 실행시키고 멈추는 작업을 반복적으로 진행한다.
즉, 원활한 멀티태스킹이 이루어지기 위해서는 각각의 프로세스마다 자신의 마지막 작업을 어디까지 진행했었는지 저장해놓을 **문맥 객체(Context)** 를 가지고 있어야 한다. (프로세스용 책갈피같은 개념)      
이렇게 프로세스들이 실행되면서 Context를 계속 옮겨가며 정보를 저장하는 행위를 **Context Switching**이라고 한다.

> **그렇다면 만약 프로세스들이 엄청 많아져서 프로세스간의 스위칭이 크게 늘어난다면 어떻게 될까?**


<br>
<br>

## 2. 구버전 웹 브라우저의 비동기 처리 방식
### 2.1 동기식 실행
동기식 실행은 프로세스간 바톤을 넘겨받는 방식이라고 생각하면 된다. 프로세스들이 절차적으로 실행되는 방식. 프로세스1이 자신의 동작을 완전히 수행해야만 프로세스 2에게 바톤을 넘겨줄 수 있다.     
만약 웹 브라우저가 동기식으로 실행된다고 생각해보자. 웹 브라우저로 검색을 하다가 프로그램을 다운로드 받을 일이 생겨서 다운로드를 눌렀다. 그러면 웹 브라우저는 다운로드가 모두 완료될때까지 다운로드 프로세스**만**을 수행한다. 만약 그 파일의 크기가 매우 크다면? 파일 하나 다운로드받자고 하루종일 검색을 못 하는 일이 발생할 수도 있다는 것이다!
     
     
### 2.2 비동기식 실행
하지만 우리의 웹 브라우저는 동기식으로 동작하지 않는다. (= 비동기식으로 동작한다.)    
오늘은 구버전 웹 브라우저의 비동기 방식에 대해서 알아보겠다.    
브라우저에서 검색을 하면 브라우저 내에서 프로세스가 실행되는 것이 아니라 fork()라는 API를 이용하여 다른 프로세스를 생성하는 방식이다(웹 브라우저가 이 기능좀 실행해달라고 접시에 담아놓으면 CPU가 포크로 콕 찍어가서 프로세스를 생성하는 느낌). 즉, 브라우저에 의해 새로운 프로세스가 만들어져서 **메인 프로세스와는 다른 별도의 프로세스** 로 인식되는 것이다.     

<div align="center">
  <img src="https://user-images.githubusercontent.com/84266499/154723114-0add619a-977a-4ad4-8d71-2a068e2d817b.png" width="800" height="400"/>
</div>

즉, 사용자가 직접 실행한 메인프로세스(브라우저)가 아니라, **메인프로세스에서 파생된 자식프로세스들을 통해 비동기를 구현** 한다.      

<br>

이러한 방식은 프로세스들이 많지 않을때는 큰 문제가 되지 않지만, 실행해야할 프로세스가 많아짐에 따라서 몇 가지 문제점이 발생할 수 있다.      
❗ 시분할 대상이 늘어난다.   
❗ 컨텍스트 스위칭에 대한 부담이 늘어나고, 업무처리시간 외에 컨텍스트 스위칭에 소요되는 시간이 늘어나서 상대적으로 업무를 처리할 시간이 줄어든다.        
❗ 메인 프로세스에서 파생되는 자식 프로세스들이 많아지면 자식 프로세스 또한 독립적인 프로세스로 인식되어 같은 자원을 할당하게 되어 프로세스간 형평성 문제가 발생한다.     
**즉, 형평성 문제 및 성능의 저하가 발생한다는 것이다!**    

이러한 문제들 때문에 프로세스 문맥 스위칭을 대신할 수 있는 대안이 필요하게 되고, 이러한 문제들을 개선한 스위칭 방법이 등장하게 되는데..... 
이것이 바로 ◾ **스레드(Threa)** ◾!!

