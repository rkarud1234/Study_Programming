# SQLD

# 1과목 1장

## 데이터 모델링

### 데이터 모델링이란?

- 데이터 모델링은 현실세계를 데이터베이스로 표현하기 위해 **추상화**한다.
- 데이터 모델링을 하기 위해서는 **고객의 업무 프로세스를 이해**해야 하며, **데이터 모델링 표기법**을 사용해서 모델링을 한다.
- 데이터 모델링은 고객의 업무 프로세스를 추상화하고, 소프트웨어를 분석, 설계하면서 점점 더 상세해진다.
- 데이터 모델링은 고객의 비즈니스 프로세스를 이해하고 비즈니스 프로세스의 규칙을 정의한다. 정의된 비즈니스 규칙을 데이터 모델로 표현한다.

- 정보 시스템을 구축하기 위한 `데이터 관점의 업무 분석 기법`
- 현실 세계의 데이터에 대해 약속된 표기법에 의해 표현하는 과정
- 데이터베이스를 구축하기 위한 분석/설계의 과정

### 데이터 모델링의 특징

- 추상화(Abstraction) : 현실세계를 간략하게 표현한다.
- 단순화(Simplification) : 누구나 쉽게 이해할 수 있도록 표현한다.
- 명확성(Clarity) : 명확하게 의미가 해석되어야 하고 한 가지 의미를 가져야 한다.

- 현실셰게를 일정한 형식에 맞추어 표현하는 `추상화`의 의미를 가짐
- 단지 시스템 구현만을 위해 수행하는 사전작업이 아닌, 시스템 구현, 업무분석, 업무 형상화의 목적이 있음
- 복잡한 현실을 제한된 언어나 표기법으로 이해하기 쉽도록 하는 `단순화`의 의미를 가짐
- 애매모호함을 배제하고 누구나 이해 가능하도록 정확하게 현상을 기술하는 `정확화`의 의미를 가짐
- 데이터 모델링 자체로 업무를 설명하고 분석하는 부분에서도 매우 중요한 의미를 가짐

### 데이터 모델링의 이유

- 업무정보를 구성하는 기초가 되는 정보들에 대해 일정한 표기법에 의해 표현함으로서 정보시스템 구축의 대상이 되는 업무 내용을 정확하게 분석
- 분석된 모델을 가지고 실제 데이터베이스를 생성하여 개발 및 데이터관리에 사용
- 단지 데이터베이스만을 구축하기 위한 용도로 쓰이는 것이 아니라 데이터모델링 자체로서 업무를 설명하고 분석하는 부분에서도 매우 중요한 의미를 가지고 있다.

### 좋은 데이터 모델의 요소

- 완전성: 업무에서 필요로 하는 모든 데이터가 정의되어 있어야 함
- 중복 배제: 하나의 DB내에 동일한 사실은 한 번만
- 업무 규칙: 데이터 모델링 과정에서 도출되고 규명되는 수많은 업무 규칙을 데이터 모델에 표현
- 데이터 재사용
- 의사소통
- 통합성: 동일한 데이터는 한 번만 정의

### 데이터 모델링 유의점

- 중복(Duplication)
    - 데이터베이스가 여러 장소에 같은 정보를 저장하는 잘못을 하지 않도록 한다.
- 비유연성(Inflexibility)
    - 데이터의 정의를 데이터의 사용 프로세스와 분리한다.
    - 데이터 혹은 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄인다.
- 비일관성(Inconsistency)
    - 데이터의 중복이 없더라도 비일관성은 발생할 수 있다.
    - 데이터와 데이터간의 상호 연관 관계에 대해 명확하게 정의하여야 한다.
    - 사용자가 처리하는 프로세스 혹은 이와 관련된 프로그램과 테이블의 연계성을 높이는 것은 데이터 모델이 업무 변경에 취약하게 만드는 단점

### 데이터 모델링 단계

1. 개념적 모델링
    - 전사적 관점에서 기업의 데이터를 모델링한다.
    - 추상화 수준이 가장 높은 수준의 모델링이다.
    - 계층형 데이터 모델, 네트워크 모델, 관계형 모델에 관계 없이 업무 측면에서 모델링한다.
    
    - 업무 중심적이고 포괄적인 수준의 모델링 진행
    - EA(Enterprise Architect) 수립 시 많이 사용
2. 논리적 모델링
    - 시스템으로 구축하고자 하는 업무에 대해 key, 속성, 관계 등을 정확하게 표현
    - 특정 데이터베이스 모델에 종속한다.
    - 식별자를 정의하고 관계, 속성 등을 모두 표현한다.
    - 정규화를 통해서 재사용성을 높인다.
3. 물리적 모델링
    - 구축할 데이터베이스 관리 시스템에 테이블, 인덱스 등을 생성하는 단계이다.
    - 성능, 보안, 가용성 등을 고려하여 데이터베이스를 구축한다.

### 데이터베이스 스키마 구조 3단계

- 개념 스키마
    - 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현
    - 데이터 모델링은 통합 관점을 가지고 있는 개념 스키마를 만들어가는 과정
- 외부 스키마
    - 사용자 뷰(View)
    - 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의
    - 전체 데이터베이스의 한 논리적인 부분(서브 스키마)
    - 같은 데이터베이스에 대해서도 서로 다른 관점을 정의할 수 있도록 허용
    - 일반 사용자는 SQL을 사용하여 DB를 사용한다
- 내부 스키마
    - 물리적 저장장치 입장에서 본 데이터베이스 구조, 물리적인 저장 장치와 밀접한 계층
    - 실제 데이터베이스에 저장될 레코드의 물리적인 구조를 정의
    - 데이터 항목의 표현방법, 내부 레코드의 물리적 순서 등을 나타냄
    - 시스템 프로그래머, 설계자가 보는 관점의 스키마

### 데이터 모델링 관점

- 데이터
    - 비즈니스 프로세스에 사용되는 데이터를 의미한다.
    - 구조 분석, 정적 분석
- 프로세스
    - 비즈니스 프로세스에서 수행하는 작업을 의미한다.
    - 시나리오 분석, 도메인 분석, 동적 분석
- 데이터와 프로세스
    - 프로세스와 데이터 간의 관계를 의미한다.
    - CRUD 분석

### 엔티티의 특징

- 반드시 해당 업무에서 필요하고 관리하고자 하는 정보여야 한다.
- 유일한 식별자에 의해 식별 가능해야 한다.
- 영속적으로 존재하는 `두 개 이상` 의 인스턴스 집합이어야 한다.
- 엔터티는반드시 속성이 있어야 한다.
- 엔티티는 다른 엔티티와 최소 한 개 이상의 관계가 있어야 한다.
- 공통코드, 통계성 엔터티의 경우는 관계를 생략할 수 있다.

### ERD란?

- 1976년 피너첸에 의해 Entity-Relationship Model이라는 표기법이 만들어졌다.
- 관계의 명칭은 관계 표현에 있어서 매우 중요한 부분에 해당한다.
- 가장 중요한 엔티티를 왼쪽 상단에 배치하고 이를 중심으로 다른 엔터티를 나열하면서 전개한다.

### 데이터 모델링을 위한 ERD 작성 절차

1. 엔터티를 도출하고 그린다.
2. 엔터티를 배치한다.
3. 엔터티 간의 관계를 설정한다.
4. 관계명을 서술한다.
5. 관계 참여도를 표현한다.
6. 관계의 필수 여부를 표현한다.

### 발생 시점에 따른 엔티티 분류

- 기본 엔티티(키 엔티티)
    - 업무에 원래 존재하는 정보
    - 다른 엔티티와의 관계에 의해 생성되지 않고 독립적으로 생성 가능
    - 타 엔티티의 부모역할을 하게 됨
    - 사원, 부서, 고객, 상품 등
- 중심 엔티티
    - 기본 엔티티로부터 발생하며 업무에 있어서 중요한 역할을 한다.
    - 데이터량이 많이 발생되고 다른 엔티티와의 관계를 통해 행위 엔티티를 생성한다
    - 계약, 청구, 주문, 매출 둥
- 행위 엔티티
    - 두 개 이상의 부모 엔티티로부터 발생
    - 자주 내용이 바뀌거나 데이터량이 증가한다
    - 분석 초기 단계에서는 잘 나타나지 않고 상세 설계나 프로세스와 상관 모델링을 하면서 도출될 수 있다.
    - 주문목록, 사원 변경이력 등

### 엔티티 명명 기준

- 가능하면 현업에서 사용하는 용어를 사용한다.
- 가능하면 약어를 사용하지 않는다.
- `단수명사`를 사용한다.
- 모든 엔티티를 통틀어서 유일하게 이름이 부여되어야 한다.
- 엔티티 생성 의미대로 이름을 부여한다.

## 속성

- 업무에서 필요로 하는 인스턴스에서 관리하고자 하는 `의미상 더 이상 분리되지 않는 최소한의 데이터 단위`
- 엔티티에 대한 자세하고 구체적인 정보를 나타냄
- 하나의 엔티티는 두 개 이상이 속성을 갖는다.
- 속성도 집합이다.

### 엔티티, 인스턴스, 속성, 속성값의 관계

- 한 개의 엔티티는 두 개 이상의 인스턴스 집합이어야 한다.
- 한 개의 엔티티는 두 개 이상의 속성을 갖는다.
- 한 개의 속성은 한 개의 속성값을 갖는다.

## 속성의 분류

- 기본 속성
    - 원래 가지고있어야 하는 속성
    - 업무로부터 추출된 일반적인 속성
- 설계 속성
    - 원래 존재하지 않지만 필요에 따라 설계자가 추가한 속성
    - 주문번호, 예약번호, 고객번호, 상품코드, 등
- 파생 속성
    - 데이터를 조회할 때 빠른 성능을 낼 수 있도록 하기 위해 원래 속성의 값을 계산하여 저장할 수 있도록 만든 속성

### 도메인

- 각 속성이 가질 수 있는 값의 범위
- 엔티티 내에서 속성에 대한 데이터타입과 제약사항을 지정하는 것
- 예) 제품명이라는 속성은 길이가 20자리 이내의 문자열로 정의할 수 있다.

### 속성 명칭

- 해당 업무에서 사용하는 이름을 부여한다
- 서술적인 속성명을 사용하지 않는다
- 약어는 가급적 사용하지 않는다
- 전체 데이터 모델에서 유일성을 확보하는 것이 좋다

### 관계의 종류

- 존재적 관계
    - 부서 - 사원의 소속 관계
- 행위에 의한 관계
    - 주분과 배송 간의 관계

### 관계의 표기법

- 관계명(Membership): 관계의 이름
- 관계차수(Cardinality): 1:1, 1:N, M:N
- 관계선택사양(Optionality): 필수 관계, 선택 관계

### 관계 도출 시 체크 사항

- 두 개의 엔티티 사이에 관심있는 연관 규칙이 존재하는가?
- 두 개의 엔티티 사이에 정보의 조합이 발생하는가?
- 업무기술서, 장표에 관계 연결에 대한 규칙이 서술되어 있는가?
- 업무기술서, 장표에 관계 연결을 가능하게 하는 동사가 있는가?

### 식별자의 종류

- 대표성 여부
    - 주 식별자: 인스턴스를 유일하게 구분할 수 있으며 참조관계를 연결할 수 있음
    - 보조 식별자: 유일하게 구분 가능하지만 대표성을 가지지 못해 참조관계 연결을 못함
- 스스로 생성 여부
    - 내부 식별자: 엔티티 내부에서 스스로 만들어지는 식별자
    - 외부 식별자: 타 엔티티와의 관계를 통해 타 엔티티로부터 받아오는 식별자
- 속성 수
    - 단일 식별자: 하나의 속성
    - 복합 식별자: 2개 이상의 속성
- 대체 여부
    - 본질 식별자: 업무에 의해 만들어지는 식별자
    - 인조 식별자: 업무적으로 만들어지지는 않지만 원조식별자가 복잡한 구성을 가지고있기 때문에 인위적으로 만든 식별자

### 주 식별자의 특징

- 유일성(unique), 최소성, 불변성, 존재성(not null)

### 주 식별자의 도출 기준

- 해당 업무에서 자주 사용되는 속성을 주식별자로 지정
- 명칭, 내역등과 같이 이름으로 기술되는 속성은 주식별자로 지정하지 않는다.
- 복합으로 주식별자를 구성하는 경우 너무 많은 속성이 포함되지 않도록 한다.

### 식별자 관계

- 부모 엔티티의 주식별자가 자식 엔티티의 주 식별자로 상속된 경우
- 강한 연결관계 표현
- 자식 주식별자의 구성에 포함됨
- 실선으로 표현
- 반드시 부모엔터티에 종속
- 자식 주식별자구성에 부모 주식별자포함 필요
- 상속받은 주식별자속성을 타 엔터티에 이전 필요

### 비식별자 관계

- 부모 엔티티의 주식별자가 자식 엔티티의 일반 속성으로 상속된 경우
- 약한 연결관계 표현
- 자식 일반 속성에 포함됨
- 점선으로 표현
- 자식 주식별자구성을 독립적으로 구성

### 비식별자 관계로 설정하는 경우

- 부모 없는 자식이 생성될 수 있는 경우
- 부모가 있었지만 자식만 남겨두고 먼저 소멸될 수 있는 경우
- 여러 엔티티가 하나의 엔티티로 통합되어 표현될 경우
- 자식 엔티티에서 별도의 주식별자를 생성하는 것이 더 유리하다고 판단될 때
- 자식과 관련이 있는 엔티티로의 주식별자 상속을 차단하기 위해

# 1과목 2장

### 성능 데이터 모델링

- 데이터베이스 성능향상을 목적으로 설계단계의 데이터 모델링 때부터 성능과 관련된 사항(정규화, 반정규화, 인덱스 등)이 데이터 모델링에 반영될 수 있도록 하는 것

### 수행시점

- 성능 향상을 위한 비용은 프로젝트 수행 중에 있어서 사전에 할수록 비용이 들지 않는다.
- 특히 분석/설계 단계에서 데이터 모델에 성능을 고려한 데이터 모델링을 수행할 경우 성능저하에 따른 재업무 비용을 최소화할 수 있는 기회를 가지게 된다.

### 성능 데이터모델링 고려사항

- 데이터모델링을 할 때 정규화를 정확하게 수행한다
- 데이터베이스 용량산정을 수행한다
- 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다
- 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다
- 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등을 수행한다.
- 성능관점에서 데이터 모델을 검증한다.

### 정규화

- 정규화는 선택이 아닌 필수
- 데이터를 결정하는 결정자에 의해 함수적 종속을 가지고 있는 일반속성을 의존자로 하여 입력/수정/삭제 이상을 제거하는 것
- 데이터의 중복속성을 제거하여 한 테이블의 데이터 용량을 최소화
- 중복된 데이터를 허용하지 않음으로서 무결성을 유지
- 데이터 처리 성능 향상, **데이터의 조회** 처리 트랜잭션 시 성능 저하가 나타날 수 있음

### 제 1 정규화

- 테이블의 컬럼이 원자값을 갖도록 테이블을 분해하는 것
- 함수 종속과 복수의 속성값을 갖는 속성을 분리하여 속성의 원자성을 확보

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f492a2be-a182-4399-9436-329c5e227c8b/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ec83d272-7d4e-4f6b-930d-4d156b91c241/Untitled.png)

### 제 2 정규화

- 제 1 정규화를 진행한 테이블에 대해 **완전 함수 종속**을 만족하도록 테이블을 분해하는 것
- 함수 종속, 주식별자에 완전 종속적이지 않는 속성, 부분 종속 속성을 분리한다.
- 완전 함수 종속: 기본키의 부분집합이 결정자가 되어선 안된다는 것

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/46b38951-37a8-4002-99b9-2fd66b38f4b1/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6da6303e-32b7-420b-9713-def1f5bd16e4/Untitled.png)

### 제 3 정규화

- 제 2정규화를 진행한 테이블에 대해 **이행정 종속**을 없애도록 테이블을 분해
- 함수 종속, 일반 속성에 종속적인 속성, 이전종속 속성을 분리한다.
- 이행적 종속: A→B, B→C가 성립할 때 A→C가 성립되는 것

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/68aade7c-7fd3-49b2-86b8-1de5c263b8c5/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/488f316c-e2bc-46b7-8d8c-3672505b4f73/Untitled.png)

### 보이스-코드 정규화(BCNF)

- 제 3정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것
- 함수 종속, 결정자 안에 함수 종속을 가진 주식별자를 분리한다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/60d9f38c-4537-4047-994c-d4f9da3c4de5/Untitled.png)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/175d4f33-b796-4ac5-a750-f04ee76fef95/Untitled.png)

### 제4 정규화

- 다가 종속 속성을 분리한다

### 제 5 정규화

- 결합 종속일 경우는 두 개 이상의 N개로 분리한다

## 반정규화와 성능

### 모델링의 특징

- 정규화된 엔터티, 속성, 관계에 대해 시스템의 성능 향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법(데이터 조회 시 성능을 향상시키는 역할)
- 데이터를 조회할 때 디스크 I/O량이 많아서 성능이 저하되거나 경로가 너무 멀어 조인으로 인한 성능저하가 예상되거나 칼럼을 계산하여 읽을 때 성능이 저하될 것으로 예상되는 경우 반정규화를 수행하게 된다.
- 일반적으로 정규화 시에는 입력/수정/삭제 성능이 향상되며 반정규화 시에는 조인 성능이 향상된다.
- 비정규화: 아예 정규화를 수행하지 않은 모델 지칭

### 반정규화 절차

1. 반정규화 대상 조사
    - 범위처리빈도수 조사 : 자주 사용되는 테이블에 접근하는 프로세스의 수가 많고 항상 일정한 범위만을 조회하는 경우
    - 대량의 범위 처리 조사 : 테이블에 대량의 데이터가 있고 대량의 데이터 범위를 자주 처리하는 경우에 처리범위를 일정하게 줄이지 않으면 성능을 보장할 수 없는 경우
    - 통계성 프로세스 조사 : 통계성 프로세스에 의해 통계 정보를 필요로 할 때 별도의 통계테이블을 생성
    - 테이블 조인 개수 : 테이블에 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우
2. 다른 방법유도 검토
    - 뷰(VIEW) 테이블 : 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 VIEW를 사용
    - 클러스터링 적용 : 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우 클러스터링을 적용하거나 인덱스를 조정
    - 인덱스의 조정 : 대량의 데이터는 PK의 성격에 따라 부분적인 테이블로 분리 가능(파티셔닝 기법)
    - 응용애플리케이션 : 응용 애플리케이션에서 로직을 구사하는 방법을 변경함으로서 성능을 향상 가능
3. 반정규화 적용
    - 테이블 반정규화
    - 속성 반정규화
    - 관계 반정규화

### 반정규화 기법

- 테이블 반정규화
    - 테이블 병합
        - 1:1 관계 테이블 병합
        - 1:M 관계 테이블 병합
        - 슈퍼/서브타입 관계 테이블 병합
    - 테이블 분할
        - 수직분할 : 칼럼단위의 테이블을 디스크 I/O로 분산처리하기 위해 테이블을 1:1로 분리하여 성능 향상
        - 수평분할 : 로우 단위로 집중발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터 접근의 효율성을 높여 성능을 향상
    - 테이블 추가
        - 중복테이블 추가 : 다른 업무이거나 서버가 다른 경우 동일한 테이블 구조를 중복하여 원격조인을 제거하여 성능을 향상
        - 통계테이블 추가 : SUM, AVG 등을 미리 수행하여 계산해 둠으로서 조회 시 성능을 향상
        - 이력테이블 추가 : 이력 테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재시켜 성능 향상
        - 부분테이블 추가: 하나의 테이블 전체 칼럼 중 자주 이용하는 집중화된 칼럼들이 있을 때 디스크 I/O를 줄이기 위해 해당 칼럼들을 모아놓은 별도의 반정규화된 테이블생성
- 칼럼 반정규화
    - 중복칼럼 추가 : 조인에 의해 처리할 때 성능저하를 예방하기 위해(=조인 감소) 중복된 칼럼을 위치시킨다.
    - 파생칼럼 추가 : 트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방하기 위해 미리 값을 계산하여 칼럼에 보관한다
    - 이력테이블 칼럼 추가 : 대량의 이력데이터를 처리할 때 불특정 날 조회나 최근 값을 조회할 때 나타날 수 있는 성능저하를 예방하기 위해 이력테이블에 기능성칼럼(최근값 여부, 시작/종료일자 등)을 추가한다
    - PK에 의한 칼럼 추가 : 복합의미를 갖는 PK를 단일 속성으로 구성하였을 경우 발생. 단일 PK안에서 특정 값을 별도로 조회하는 경우 성능저하가 발생할 수 있다. 이 때 이미 PK안에 데이터가 존재하지만 성능향상을 위해 일반속성을 포함한다
    - 응용시스템 오작동을 위한 칼럼 추가 : 업무적으로는 의미가 없지만 사용자가 데이터처리를 하다가 잘못 처리하여 원래값으로 복구를 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법
- 관계 반정규화
    - 중복관계 추가 : 데이터를 추가하기 위한 여러 경로를 거쳐 조인이 가능하지만 이 때 발생할 수 있는 성능저하를 예방하기 위해 추가적인 관계를 맺는 방법

## 대량 데이터에 따른 성능

### 데이터 발생에 따른 테이블 분할 개요

- 로우체이닝 (Row Chaining)
    - 로우 길이가 너무 길어서 데이터 블록 하나에 데이터텍스트가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태
- 로우마이그레이션 (Row Migration)
    - 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식

### 파티셔닝 : PK에 의해 테이블 분할

- 하나의 테이블에 많은 양의 데이터가 저장되면 인덱스를 추가하고 테이블을 몇 개로 쪼개도 성능이 저하되는 경우가 있다
- 이 때 논리적으로는 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리하여 데이터 액세스 성능도 향상시키고 데이터 관리 방법도 개선할 수 있도록 테이블에 적용하는 기법
- RANGE PARTITION
    - 대상 테이블이 날짜 또는 숫자 값으로 분리가 가능하고 각 영역별로 트랜잭션이 분리될 때 적용
- LIST PARTITION
    - 지점, 사업소, 사업장, 핵심적인 코드 값 등으로 PK가 구성되어 있고 대량의 데이터가 있는 테이블일 때 적용
- HASH PARTITION
    - 지정된 HASH 조건에 따라 해시 알고리즘이 적용

### 테이블에 대한 수평/수직분할 절차

1. 데이터 모델링을 완성한다
2. DB 용량산정을 한다
3. 대량 데이터가 처리되는 테이블에 대해 트랜잭션 처리 패턴을 분석한다
4. 칼럼 단위로 집중화된 처리가 발생하는지, 로우 단위로 집중화된 처리가 발생하는지 분석하여 집중화된 단위로 테이블을 분리하는 것을 검토한다

## 분산 데이터베이스

- 데이터베이스를 연결하는 빠른 네트워크 환경을 이용하여 데이터베이스를 여러 지역 여러 노드로 위치시켜 사용성/성능 등을 극대화시킨 데이터베이스
- 여러 곳에 분산되어 있는 DB를 하나의 가상 시스템으로 사용할 수 있도록 한 데이터베이스
- 논리적으로 동일한 시스템에 속하지만 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터 집합

### 분산 데이터베이스의 투명성 (Transparency)

- 분할 투명성(단편화)
    - 하나의 논리적 relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장
- 위치 투명성
    - 사용하려는 데이터의 저장 장소 명시 불필요
    - 위치 정보가 시스템 카탈로그에 유지되어야 함
- 지역사상 투명성
    - 지역 DBMS와 물리적 DB 사이의 mapping 보장
    - 각 지역 시스템 이름과 무관한 이름 사용 가능
- 중복 투명성
    - DB객체가 여러 site에 중복되어 있는지 알 필요가 없는 성질
- 장애 투명성
    - 구성요소(DBMS, computer)의 장애에 무관한 transaction의 원자성 유지
- 병행 투명성
    - 다수 트랜잭션 동시 수행 시 결과의 일관성 유지, TimeStamp, 분산 2단계 locking이용 구현

### 분산 데이터베이스의 장단점

- 장점
    - 지역 자치성, 점중적 시스템 용량 확장
    - 신뢰성, 가용성, 효용성, 융통성
    - 빠른 응답 속도와 통신비용 절감
    - 데이터 가용성과 신뢰성 증가
    - 시스템 규모의 적절한 조절
    - 각 지역 사용자의 요구 수용 증대
- 단점
    - 소프트웨어 개발 비용
    - 오류의 잠재성 증대
    - 처리 비용의 증대
    - 설계, 관리의 복잡성과 비용
    - 불규칙한 응답 속도
    - 통제의 어려움
    - 데이터 무결성에 대한 위험

### 분산 데이터베이스의 적용 기법

- 테이블 위치 분산
    - 테이블의 위치를 각각 다르게 위치
    - 테이블 구조 변하지 않고 다른 DB에 중복생성 X
- 테이블 분할(Fragmentation) 분산
    - 각각의 테이블을 쪼개서 분산
    - 수평분할: Row 단위로 분할, PK에 의한 중복이 발생하지 않음
    - 수직분할: Column 단위로 분할, 동일한 PK 구조와 값을 가지고 있어야 함
- 테이블 복제(Replication) 분산
    - 동일한 테이블을 다른 지역이나 서버에 동시에 생성하여 관리
    - 부분복제: 마스터 테이블의 일부의 내용만 다른 지역이나 서버에 위치시킴
    - 광역복제: 마스터 테이블의 내용을 각 지역이나 서버에 존재시킴
- 테이블 요약(Summarization) 분산
    - 지역 또는 서버간의 데이터가 비슷하지만 서로 다른 유형으로 존재하는 경우
    - 분석요약: 동일한 내용의 데이터를 이용하여 통합된 데이터를 산출
    - 통합요약: 다른 내용의 데이터를 이용하여 통합된 데이터를 산출
    

### 분산 데이터베이스 설계를 고려해야 하는 경우

- 성능이 중요한 사이트
- 공통코드, 기준정보, 마스터 데이터의 성능향상
- 실시간 동기화가 요구되지 않는 경우, 거의 실시간의 업무적인 특징을 가지고 있는 경우
- 특정 서버에 부하가 집중되어 부하를 분산
- 백업 사이트 구성하는 경우

# 2과목 1장

### DCL : 권한

- GRANT: 권한 부여, REVOKE: 권한 회수
    - GRANT 권한 ON 테이블 TO 유저
    - REVOKE 권한 ON 테이블 FROM 유저
- GRANT 옵션
    - TO 유저 WITH GRANT OPTION : 부모의 권한을 회수할 때 자식의 권한도 회수
    - TO 유저 WITH ADMIN OPTION
        - 테이블에 대한 모든 권한 부여
        - 부모 권한 회수는 상관 없음
        
- 관리자 권한 : ROLE

### DDL : 데이터 구조 정의

- **CREATE**
    - 테이블 구조 생성
    
    ```sql
    CREATE TABLE 테이블명 
    (
    	속성명 자료형,
    	이름   varchar2(10),
      생일   date
    );
    ```
    
    - 컬럼명
        - 영문, 한글, 숫자 모두 가능
        - 시작은 무조건 문자로 해야 함(숫자, 특수문자X)
    - 자료형
        - `number` : 숫자
        - `date` : 날짜
        - `varchar` : 가변길이 문자열
        - `char` : 고정길이 문자열, 할당된 길이만큼 공백으로 채워짐
- 제약조건(CONSTRAINT)
    - default : 기본값 지정
    - not null, primary key, foreign key
- NULL
    - 모르는 값, 값의 부재를 의미함
    - NULL **IS** NULL = TRUE, NULL **IS NOT** NULL = FALSE
    - `NULL = 0` : 알 수 없음(NULL) 반환
    - `NULL * 10` : NULL
    - NULL은 숫자 0이나 공백문자와 동일하지 않음
- **ALTER**
    - 테이블과 컬럼에 대해서 이름 및 속성 변경, 추가/삭제 등 구조 수정을 위해 사용
    
    ```sql
    -- 테이블명 변경
    ALTER TABLE 테이블명 RENAME TO 바꿀이름;
    RENAME TABLE 테이블명 TO 바꿀이름;
    
    -- 컬럼명 변경
    ALTER TABLE 테이블명 RENAME COLUMN 컬럼명 TO 바꿀컬럼이름;
    
    -- 컬럼속성 변경
    ALTER TABLE 테이블명 MODIFY (컬럼명 자료형 제약조건);
    
    -- 컬럼 추가
    ALTER TABLE 테이블명 ADD (컬럼명 자료형 제약조건);
    
    -- 컬럼 삭제
    ALTER TABLE 테이블명 DROP 컬럼명;
    
    -- 테이블에 제약조건 추가/삭제
    ALTER TABLE 테이블명 ADD CONSTRAINT;
    										DROP CONSTRAINT;
    ```
    
- **DROP**
    - 테이블 및 컬럼 삭제
    
    ```sql
    -- 테이블 삭제
    DROP TABLE 테이블명;
    
    -- 컬럼 삭제
    ALTER TABLE 테이블명 DROP COLUMN 컬럼명;
    
    -- 해당 테이블의 데이터를 외래키(FK)로 참조한 제약사항도 모두 삭제
    -- Oracle에만 있는 옵션. SQL Server에는 존재하지 않음
    -- FK제약조건과 참조테이블 먼저 삭제하고, 해당 테이블을 삭제한다
    DROP TABLE 테이블명 CASCADE CONSTRAINT;
    ```
    
- **DROP** VS **TRUNCATE**
    - DROP : 테이블 관련해서 모두 삭제
    - TRUNCATE
        - `TRUNCATE TABLE 테이블명`
        - DROP 후 CREATE
        - 테이블의 데이터만 삭제하고 구조는 살아있다
        

### DML : 레코드 삽입, 수정, 삭제

- **INSERT**
    - `INSERT INTO 테이블명 (컬럼) VALUES (컬럼값);`
- **UPDATE**
    - `UPDATE 테이블명 SET 컬럼=값 | WHERE 조건`
- **DELETE**
    - `DELETE FROM 테이블명 | WHERE 조건`
    - `DELETE 테이블명`

### TCL : 데이터베이스 변경 제어

- **COMMIT**
    - 데이터에 대한 변화를 DB에 반영하기 위한 명령어
- **ROLLBACK**
    - 트랜잭션이 시작되기 이전의 상태로 되돌리기 위한 언어
    - 최신 COMMIT이나 특수한 SAVEPOINT로 돌릴 수 있음
- **SAVEPOINT**
    - 코드를 분할하기 위한 저장 포인트 지정

```sql
-- SAVEPOINT 정의
SAVEPOINT 세이브포인트명;

-- ROLLBACK : SAVEPOINT로 돌아가기
ROLLBACK TO SAVEPOINT 세이브포인트명;
ROLLBACK 세이브포인트명;

-- ROLLBACK : 최신 커밋으로 돌아가기
ROLLBACK;

-- COMMIT
COMMIT;
```

- 효과
    - 데이터 무결성을 보장할 수 있다
    - 영구적인 변경 전 데이터에 대한 변동사항을 확인할 수 있다
    - 논리적 연관성이 있는 작업을 그룹화해서 처리할 수 있다.
- 트랜잭션의 특징
    - 고립성 : 트랜잭션이 실행되는 동안 다른 트랜잭션에 영향을 받아 잘못된 결과를 만들어선 안된다
    - 원자성 : 트랜잭션에서 정의된 연산은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 있어야한다
    - 지속성 : 트랜잭션이 성공적으로 완료되면 해당 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다
    - 일관성 : 트랜잭션 발생 전 데이터베이스 내용에 잘못된 점이 없다면 트랜잭션 수행 후에도 데이터베이스의 내용에 잘못이 있으면 안된다

### SELECT : 데이터 조회

- 기본 구조

```sql
SELECT 컬럼 등
FROM 테이블명
WHERE 조건문
GROUP BY 집계 기준
HAVING 집계 조건
ORDER BY 컬럼명 (ASC, DESC)
```

- **실행 순서**
    - FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY
- **쿼리 순서**
    - SELECT - FROM - WHERE - GROUP BY - HAVING - ORDER BY
    
- **DISTINCT**
    - 중복 제거
    - NULL도 단일행으로 취급
- **문자형 함수**
    - LOWER(문자열) : 영어 문자열 소문자로 변환
        - `LOWER('Hello World!')` >> `hello world!`
    - UPPER(문자열) : 영어 문자열 대문자로 변환
        - `UPPER('Hello World!')` >> `HELLO WORLD!`
    - CONCAT(문자열1, 문자열2) : 문자열1과 문자열2를 결합
        - `CONCAT('Hello', 'World')` >> `Hello World`
        - SQL Server : + (`안녕 + 하세요` = `안녕하세요`)
        - Oracle : ||  (`안녕 || 하세요` = `안녕하세요`)
        - concat함수의 경우 인수는 **단 두개**여야 한다.
    - SUBSTR(문자열, m, n) : 문자열에서 m번째 자리값부터 n개를 자른다
        - `SUBSTR('Hello World', 2, 2)` >> `el`
            - 5번째 문자열부터 읽기
                - `SUBSTR('동해물과백두산이' FROM 5)` = 백두산이
                - `SUBSTRING('동해물과백두산이',5)` = 백두산이
            - 3번째부터 4글자 읽기
                - `SUBSTR('동해물과백두산이' FROM 3 FOR 4)` = 물과백두
                - `SUBSTRING('동해물과백두산이', 3, 4)` = 물과백두
            - 뒤에서 4번째 문자부터 읽기
                - `SUBSTR('동해물과백두산이' FROM -4)` = 백두산이
                - `SUBSTRING('동해물과백두산이',-4)` = 백두산이
            - 뒤에서 6번째부터 4글자 읽기
                - `SUBSTR('동해물과백두산이' FROM -6 FOR 4)` = 물과백두
                - `SUBSTRING('동해물과백두산이', -6, 4)` = 물과백두
    - LENGTH(문자열), LEN(문자열) : 공백을 포함한 문자열의 길이
        - `LEN('Hello World!')` >> `12`
    - TRIM(문자열, 제거대상) : 문자열에서 해당 문자 제거
        - `TRIM('Hello World!', 'l')` >> `Heo Word!`
        - 문자열 지정 안하면 양끝의 공백이 제거됨
    - LTRIM(문자열, 제거대상) : 왼쪽에서 지정된 문자 삭제
        - 없으면 왼쪽 공백 삭제
    - WHERE문이나 JOIN과 같이 사용 가능
    - **Lpad/Rpad**
        - 지정한 길이가 될 때까지 왼쪽/오른쪽부터 지정한 문자로 문자열을 채운다
        - 문자를 따로 지정하지 않을 경우 공백으로 채워진다.
        - `LPAD("원본문자열", 지정한 자릿수, "채워질 문자")`
        - `LPAD('aa', 6, 'b')` = bbbbaa
        - `RPAD('aa', 6, 'b')` = aabbbb
    
- **숫자 함수**
    - ROUND(숫자, 소숫접 자릿수) : 반올림
    - TRUNC(숫자, 소숫점 자릿수) : 버림
    - CEIL(숫자) : 크거나 같은 최소 정수
        - **Ceil** (Oracle), **Ceiling** (SQLServer)
    - FLOOR(숫자) : 작거나 같은 최소 정수
    - MOD(분자, 분모) : 분자를 분모로 나눈 나머지 반환
    - SIGN(숫자) : 숫자가 양수면 1, 0이면 0, 음수면 -1
    - ABS(숫자) : 절댓값
    - SYSDATE : 현재 날짜&시각 출력
    - EXTRACT(정보 FROM 날짜) : 날짜형 데이터에서 원하는 값을 추출
        - `EXTRACT ( YEAR FROM date '2022-01-31')` >> 2022
        - 정보 : YEAR, MONTH, DAY, HOUR, MINUTE, SECOND
        - `EXTRACT (YEAR FROM sysdate)` == `TO_NUMBER(TO_CHAR(sysdate, 'YYYY'))`
    - TO_NUMBER(문자열) : 문자열을 숫자로 변환
    - TO_CHAR(숫자 or 날짜, 포맷) : 숫자 혹은 날짜형 데이터를 포맷에 맞게 문자로 바꿈
        - `TO_CHAR(date ‘2022-02-11’, ‘day’)` >> `금요일`
        - `TO_CHAR(200)` >> `200`
    - TO_DATE(문자열, 포맷)
        - `TO_DATE('2022013120', 'YYYYMMDDHH24')` >> `2022/01/31 20:00:00`

<aside>
💡 **명시적 형변환과 암시적 형변환

º 명시적 형변환
   :** 형변환 함수(TO_NUMBER, TO_CHAR 등)을 사용하여 강제로 DATA TYPE을 변경하는 것

**º 암시적 형변환**
   : INSERT, SELECT 등을 할 때 데이터베이스가 알아서 DATA TYPE을 변경하는 것

</aside>

- **DECODE**
    - IF문
    - `DECODE(컬럼, 조건1, 결과1, 조건2, 결과2, ...)`
- **CASE WHEN**
    
    ```sql
    case 컬럼
    	when 조건1 then 값1
    	when 조건2 then 값2
    else 값3
    end
    ```
    
    - else가 없으면 null
- **WHERE : 조건문**
    - IN(X, Y, Z, …) : 이것들 중 하나만 일치해도 됨
        - `A in (1, 2, 3)` = `A=1 or A=2 or A=3`
    - NOT IN(X, Y, Z, …) : 하나라도 일치하면 안됨
    - IS NULL
    - IS NOT NULL
    - BETWEEN a AND b
        - `A between 1 and 2` = `1 ≤ A ≤ 2`
    - 비교연산자(=, >, ≥, <, ≤ …)
    - **LIKE**
        - 와일드카드
            - _ : 미지의 한 글자
            - % : 0 이상의 글자
            - `user_name like '_L%'` = 두 번째 글자가 L인 회원의 이름을 조회
        - escape : 와일드카드( _, %)를 문자로 취급해 검색하고 싶을 때
            - `user_name like 'A@_A' escape @` = 이름이 A_A인 회원 조회
            - 꼭 @가 아니고 # 등 아무 문자여도 됨
- **WITH 구문**
    - 서브쿼리를 사용해서 임시테이블이나 뷰 처럼 사용 가능
    - 별칭 지정 가능
    - 인라인뷰나 임시테이블로 판단
    
    ```sql
    WITH 별칭 AS (
    	SELECT *
    	FROM 테이블
    	WHERE 조건
    )
    ```
    
    - 서브쿼리 : SELECT문 내에 SELECT문이 또 쓰여져있는 쿼리
    - 인라인뷰: 서브쿼리가 FROM절 내에 쓰여진 것
    - VIEW 테이블
        - 일종의 가상테이블로서 실제 데이터가 하드웨어에 저장되는것은 아님
        - 실제 데이터를 가지고 있지 않다
        - 테이블 구조가 변경되더라도 독립적으로 존재
        - 사용상의 편의를 위해 사용
        - 수행속도 향상을 위해 사용
        - SQL의 성능을 향상시키기 위해 사용
        - 임시적인 작업을 위해 사용
        - 보안관리를 위해 사용
- **NULL**
    - 부재, 모르는 값
    - `null + 2` , `null - 4` , `null * null` 은 모두 **unkown**이다
        - where절의 조건에 null이 포함된다면(`null=2` 등) **False**
    - 정렬 할 시
        - Oracle : **∞**
        - SQLServer : -**∞**
    - 다양한 함수들
        - `NVL(”값1”, “값2”)` : 값1!=null ? 값1:값2
        - `NVL2("값1", "값2", "값3")` : 값1 != null ? 값2:값3
        - `isNull("값1", 값2")` : NVL과 동일
        - `Nullif("값1", "값2")` : 값1==값2 ? null:값1
        - `coalesce("값1", "값2", "값3", ....)` : 인수는 무한대, null이 아닌 첫 번째 값
- **GROUP BY**
    - Oracle: NULL 포함, SQL Server : NULL 제외
    - GROUP BY 안에서는 AS 사용불가
- **집계함수**
    - 통계적 집계함수를 연산할 때 NULL은 제외하고 연산한다
    - COUNT(*) : NULL 포함, COUNT(exp) : NULL 제외
    - SUM( [DISTINCT | ALL ] exp ) : 합계
    - AVG( [DISTINCT | ALL ] exp ) : 평균
    - MAX( [DISTINCT | ALL ] exp ) : 최대값
    - MIN( [DISTINCT | ALL ] exp ) : 최소값
    - STDDEV( [DISTINCT | ALL ] exp ) : 표준편차
    - VARIAN( [DISTINCT | ALL ] exp ) : 분산
- 조회 시 특정 개수까지만 조회
    - **Rownum** (Oracle)
        - 특정 개수만 추출하거나 순번을 부여하고 싶을 때 사용
        - where 조건 절로 몇 개 추출할 지 정할 수 있음
        - rownum은 적층 구조이다 ⇒ 무조건 1부터 시작해야함 `where rownum=2` 와 같은 것은 불가능 (`WHERE ROWNUM ≤ 2`)
        - rownum에 의한 조건 절은 **order by 이전에 실행**됨을 주의! **order by가 항상 마지막!**
    - **Top** (SQLServer)
        - `select top(3) user_name` = 상위 세 개의 회원 이름만을 조회
    - **LIMIT** (MySQL)
        - `SELECT * FROM 테이블 LIMIT 1`

- GROUP 함수들
    - ROLLUP : 부분합계와 전체합계값을 보여준다
    - CUBE : 그룹화될 수 있는 모든 경우에 대해 생성
    - GROUPING SETS(속성, 속성) : 괄호 묶은 집합별 집계 가능
    - GROUPING : 소계, 합계 등이 계산되면 1을 반환하고, 아니면 0을 반환한다

### 집합연산자

- Union : 합집합, 중복데이터 사라짐
- Intersect : 교집합
- Minus (Oracle), Except (SQLServer) : 차집합
- UnionAll
    - 중복데이터 존재
    - 정렬작업 없다 ⇒ 빠르다

### 서브쿼리

- 서브쿼리 결과가 2건 이상 반환될 수 있는 경우 ⇒ **다중 행 비교 연산자**
    
    
    | IN | 서브쿼리 결과 중 임의의 값과 동일 |
    | --- | --- |
    | ALL | 서브쿼리 결과의 모든 값을 만족 |
    | ANY | 서브쿼리 결과 중 어느 하나의 값이라도 만족 |
    | EXISTS | 서브쿼리 결과 중 값이 존재하는지 여부 |

### JOIN

- natural join - using
    - 중복된 컬럼이 하나로 출력됨
    - 중복된 컬럼이 제일 앞에 등장
    - as 사용 안됨
- left outer join
    - A left outer join B
- Join 순서
    - `FROM A,B,C` 에서 순서는 A,B를 조인한 테이블에 C를 조인

### 집계함수

- **null과의 관계 중요**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6a60593b-cb65-4be4-87ea-ebfdc389ea0b/Untitled.png)

- SUM(A) = 3    SUM(B) = 4
- COUNT(A) = 1    COUNT(*) = 3
- SUM(A+B+C) = 위부터 null 7 null

### 논리연산자

- AND
- OR
- NOT
- 연산자의 우선순위 : **N**OT > **A**ND > **O**R

### 정렬

- 정렬의 특징
    - order by는 **항상 마지막에 실행**된다
    - 성능이 느려질 가능성이 있다
    - null값과의 관계(위 참조)
- 컬럼 번호 정렬
    - `SELECT * FROM 테이블 WHERE 조건식 ORDER BY 컬럼 번호1 [, 컬럼 번호2, 컬럼 번호3 ...]`
    - 출력되는 컬럼의 수보다 큰 값은 불허
- 인수 두 개로 정렬
    - `ORDER BY salary desc, ename asc`
    - salary가 같으면 ename 오름차순
- 출력되지 않는 컬럼으로 정렬 가능
    - `SELECT ename ORDER BY sal`

### 계층형 조회

START WITH

CONNECT BY PRIOR

ORDER SIBLINGS BY

### 윈도우 함수

```sql
SELECT WINDOW_FUNCTION (AGRUMENTS) 
OVER ([PARTITION BY 컬럼명] [ORDER BY 컬럼명] [WINDOWING] ) 
FROM 테이블명;
```

- WINDOW_FUNCTION : 윈도우 함수
    - COUNT, SUM, MIN, MAX AVG 등
    - RANK 함수
        - RANK
            - 동일한 순위에 대해 동일한 순위를 부여
            - 공동1위 다음에 3위
        - DENSE_RANK
            - 동일한 순위에 대해 동일한 순위를 부여
            - 공동1위 다음에 2위
        - ROW_NUMBER
            - 동일한 순위에 대해서도 다른 값을 부여
    - 비율 관련 함수
        - PERCENT_RANK : 파티션 내에서의 백분율
        - NTILE(n) : 파티션별로 전체 건수를 n등분한 값을 반환
        - CUME_DIST : 파티션 내에서 현재 행 값 이하인 레코드 건수에 대한 누적 백분율 조회(0~1)
    - 행 순서 함수
        - FIRST_VALUE : 파티션 내에서 가장 처음 나오는 값
        - LAST_VALUE : 파트션 내에서 가장 마지막에 나오는 값
        - LAG(컬럼명, 레코드위치차이값) : 이전 행을 가져온다
        - LEAD(컬럼명, 레코드위치차이값, NULL일경우 대체값) : 다음 행을 가져온다(DEFAULT 1)
- ARGUMENTS : 인수 (컬럼명 등 함수의 작업이 이뤄지는 대상)
- PARTITION BY : 테이블의 레코드들을 쪼개는 기준
- ORDER BY : 정렬
- WINDOWING : 함수의 연산 대상이 되는 레코드의 범위를 정함

### 옵티마이저

- SQL 실행계획을 수립해주는 놈

SQL문 작성 - Parsing - 옵티마이저 - 실행계획 - SQL 실행

- 비용기반 옵티마이저
    - 비용이 저렴한 쪽으로
- 규칙기반 옵티마이저
    - 정해놓은 규칙의 우선순위를 기준으로

### 인덱스

- 데이터의 색인(목차)
- 데이터를 빠르게 조회할 수 있도록 해주는것
- 인덱스는 인덱스 키를 기준으로 정렬되어있다
- pk는 자동적으로 인덱스가 된다
- 하나의 테이블에 여러 개의 인덱스를 생성할 수 있고, 하나의 인덱스는 여러 컬럼으로 구성될 수 있다
- 인덱스의 종류
    - Index Unique SCAN : 인덱스 키값이 중복되지 않을 때 해당 키를 통해 탐색
    - Index Range SCAN : WHERE문을 사용하여 해당 영역을 스캔
    - Index Full SCAN : 인덱스 처음부터 끝까지 모두 스캔
